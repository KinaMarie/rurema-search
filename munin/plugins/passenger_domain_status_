#!/usr/bin/env ruby
#
# Copyright (C) 2010  Kouhei Sutou <kou@clear-code.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#%# family=auto
#%# capabilities=autoconf suggest

require 'rubygems'

@domain = File.basename($0).gsub(/milter_manager_/, '')
@domain = nil if @domain and @domain.empty?

mode = ARGV[0]

def passenger_status_path(gem_path)
  File.join(gem_path, "bin", "passenger-status")
end

@label = ENV["label"]
@pid_file = ENV["pid_file"]
@ruby = ENV["ruby"] || Gem.ruby
@gem_path = ((ENV["GEM_HOME"] || '').split(/:/) + Gem.path).find do |path|
  File.exist?(passenger_status_path(path))
end

def passenger_status
  if @pid_file
    unless File.readable?(@pid_file)
      return [false, "PID file isn't readable: #{@pid_file}"]
    end
    pid = File.read(@pid_file).strip
  else
    pid = nil
  end
  result = `#{@ruby} #{passenger_status_path(@gem_path)} #{pid}`
  [$?.success?, result]
end

def parse_uptime(uptime)
  uptime_in_minutes = 0
  if /\A(?:(?:(\d+)h\s+)?(\d+)m\s+)?(\d+)s\z/ =~ uptime
    hours = $1.to_i
    minutes = $2.to_i
    seconds = $3.to_i
    uptime_in_minutes = minutes + hours * 60
  end
  uptime_in_minutes
end

def parse_result(result)
  sections = {}
  section = nil
  domain = nil
  result.each_line do |line|
    case section
    when "Domains"
      case line.chomp
      when /\A(.+):\z/
        domain = $1
        sections[section] << [domain, []]
      when /\A\s+PID:\s+(\d+)\s+
                 Sessions:\s+(\d+)\s+
                 Processed:\s+(\d+)\s+
                 Uptime:\s+(.+)\z/x
        pid = $1.to_i
        sessions = $2.to_i
        processed = $3.to_i
        uptime = parse_uptime($3)
        sections[section].last.last << {:pid => pid,
                                        :sessions => sessions,
                                        :processed => processed,
                                        :uptime => uptime}
      end
    else
      if /-+\s+(.+)\s+-+/ =~ line
        section = $1
        sections[section] = []
      end
    end
  end
  sections
end

def key_prefix(pid)
  "pid#{pid}"
end

def config
  success, result = passenger_status
  unless success
    puts result
    exit(false)
  end

  if @label
    title = "Passenger: #{@label}: #{@domain}: status"
  else
    title = "Passenger: #{@domain}: status"
  end
  sections = parse_result(result)
  puts(<<-EOC)
graph_title #{title}
graph_category passenger
graph_info Passenger #{@domain} status

EOC
  sections["Domains"].each do |domain, processes|
    processes.each do |attributes|
      _key_prefix = key_prefix(attributes[:pid])
      label_prefix = "PID #{attributes[:pid]}"

      puts("#{_key_prefix}_sessions.label #{label_prefix} sessions")
      puts
      puts("#{_key_prefix}_processed.label #{label_prefix} processed")
      puts
      puts("#{_key_prefix}_uptime.label #{label_prefix} uptime (min)")
      puts
    end
  end
end

def report
  success, result = passenger_status
  unless success
    puts result
    exit(false)
  end

  sections = parse_result(result)
  sections["Domains"].each do |domain, processes|
    processes.each do |attributes|
      _key_prefix = key_prefix(attributes[:pid])
      puts("#{_key_prefix}_sessions.value #{attributes[:sessions]}")
      puts("#{_key_prefix}_processed.value #{attributes[:processed]}")
      puts("#{_key_prefix}_uptime.value #{attributes[:uptime]}")
    end
  end
end

case mode
when "auto", "autoconf", "detect"
  success, result = passenger_status
  if success
    puts "yes"
    exit(true)
  else
    puts "no (#{result})"
    exit(false)
  end
when "suggest"
  success, result = passenger_status
  if success
    domains = result["Domains"]
    if domains
      domains.each do |domain, processes|
        puts domain
      end
      exit(true)
    else
      puts "no domain: #{result.inspect}"
      exit(false)
    end
  else
    puts result
    exit(false)
  end
else
  if @domain.nil?
    puts "no domain"
    exit(false)
  end
  case mode
  when "config"
    config
  else
    report
  end
end
